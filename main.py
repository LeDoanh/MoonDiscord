import asyncio
import os

import discord
from discord import app_commands
from discord.ext import commands
from fastapi import FastAPI
from openai import AsyncOpenAI

from config import Config

# --- Load configuration ---
config = Config()
DISCORD_TOKEN = config.discord_token
OPENAI_API_KEY = config.openai_api_key
STATUS = config.status
OPENAI_BASE_URL = config.openai_base_url
OPENAI_MODEL = config.openai_model
OPENAI_INSTRUCTIONS = config.openai_instructions

# --- Initialize channel chat IDs dictionary ---
CHANNEL_CHAT_IDS = {}  # key: channel_id (str), value: chat_id (str or None)

# --- Initialize OpenAI client ---
openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY, base_url=OPENAI_BASE_URL)

app = FastAPI()


@app.get("/")
async def root():
    return {"status": "Moon Discord bot is running!"}


# --- Custom Bot with setup_hook for slash commands ---
class MoonBot(commands.Bot):
    async def setup_hook(self):
        await self.add_cog(ChatCommand(self))
        await self.tree.sync()
        self.tree_synced = True


# --- Initialize bot with intents ---
intents = discord.Intents.default()
intents.message_content = True
bot = MoonBot(command_prefix="!", intents=intents)


# --- Slash command for chat ---
class ChatCommand(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @app_commands.command(name="chat", description="üí¨ G·ª≠i c√¢u h·ªèi t·ªõi Moon")
    @app_commands.describe(
        question="C√¢u h·ªèi ho·∫∑c n·ªôi dung mu·ªën h·ªèi",
        tool="C√¥ng c·ª• h·ªó tr·ª£: None, Web search",
    )
    @app_commands.choices(
        tool=[
            app_commands.Choice(name="None", value="none"),
            app_commands.Choice(name="Web search", value="web_search"),
        ]
    )
    async def chat(
        self,
        interaction: discord.Interaction,
        question: str,
        tool: app_commands.Choice[str] = None,
    ):
        channel_id = str(interaction.channel_id)
        chat_id = CHANNEL_CHAT_IDS.get(channel_id)
        await interaction.response.defer(thinking=True)
        user_mention = interaction.user.mention
        tool_value = tool.value if tool else "none"
        answer, new_chat_id = await ask_openai(
            question, tool=tool_value, chat_id=chat_id
        )
        CHANNEL_CHAT_IDS[channel_id] = new_chat_id
        await interaction.followup.send(f"{user_mention} {answer}")

    @app_commands.command(name="new_chat", description="üÜï B·∫Øt ƒë·∫ßu ch·ªß ƒë·ªÅ m·ªõi v·ªõi Moon")
    async def new_chat(self, interaction: discord.Interaction):
        channel_id = str(interaction.channel_id)
        CHANNEL_CHAT_IDS[channel_id] = None
        await interaction.response.send_message(
            f"Moon b·∫Øt ƒë·∫ßu ch·ªß ƒë·ªÅ m·ªõi r·ªìi n√®, {interaction.user.mention} h·ªèi g√¨ ti·∫øp ƒëi ·∫°! ‚ú®"
        )

    @app_commands.command(name="help", description="‚ùì H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Moon")
    async def help(self, interaction: discord.Interaction):
        help_text = (
            "**Moon Discord Bot H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:**\n"
            "- `/chat <c√¢u h·ªèi> [tool]`: G·ª≠i c√¢u h·ªèi t·ªõi Moon, c√≥ th·ªÉ ch·ªçn c√¥ng c·ª• h·ªó tr·ª£ nh∆∞ Web search.\n"
            "- `/new_chat`: B·∫Øt ƒë·∫ßu ch·ªß ƒë·ªÅ tr√≤ chuy·ªán m·ªõi v·ªõi Moon.\n"
            "- ƒê·ªÅ c·∫≠p @MoonBot trong k√™nh ƒë·ªÉ h·ªèi nhanh b·∫±ng tin nh·∫Øn th∆∞·ªùng.\n"
            "\n"
            "**V√≠ d·ª•:**\n"
            "- `/chat T√¥i c·∫ßn tin t·ª©c m·ªõi nh·∫•t v·ªÅ AI`\n"
            "- `/chat H√£y t√¨m gi√∫p t√¥i c√°c c√¥ng c·ª• h·ªçc ti·∫øng Anh hay nh·∫•t tool:Web search`\n"
            "\n"
            "**L∆∞u √Ω:**\n"
            "- Moon s·∫Ω tr·∫£ l·ªùi trong v√≤ng v√†i gi√¢y, n·∫øu kh√¥ng th·∫•y ph·∫£n h·ªìi c√≥ th·ªÉ do l·ªói m·∫°ng ho·∫∑c qu√° t·∫£i.\n"
            "- N·∫øu b·∫°n c·∫ßn b·∫Øt ƒë·∫ßu l·∫°i cu·ªôc tr√≤ chuy·ªán, h√£y s·ª≠ d·ª•ng l·ªánh `/new_chat`.\n"
            "- Moon c√≥ th·ªÉ s·ª≠ d·ª•ng c√¥ng c·ª• t√¨m ki·∫øm web ƒë·ªÉ cung c·∫•p th√¥ng tin ch√≠nh x√°c h∆°n.\n"
            "- H√£y th∆∞·ªùng xuy√™n s·ª≠ d·ª•ng /new_chat ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªß ƒë·ªÅ m·ªõi, tr√°nh l√†m l·ªôn x·ªôn cu·ªôc tr√≤ chuy·ªán.\n"
            "\n"
            "N·∫øu c·∫ßn h·ªó tr·ª£ th√™m, h√£y li√™n h·ªá admin server!"
        )
        await interaction.response.send_message(help_text, ephemeral=True)


# --- Function to send prompt to OpenAI and return the response ---
async def ask_openai(
    prompt: str, tool: str = "none", chat_id: str = None
) -> tuple[str, str]:
    tools = []
    if tool == "web_search":
        tools.append(
            {
                "type": "web_search_preview",
                "search_context_size": "medium",
                "user_location": {
                    "type": "approximate",
                    "country": "VN",
                },
            }
        )
    try:
        response = await openai_client.responses.create(
            model=OPENAI_MODEL,
            instructions=OPENAI_INSTRUCTIONS,
            previous_response_id=chat_id,
            input=prompt,
            tools=tools if tools else None,
        )
        new_chat_id = getattr(response, "id", chat_id)
        return response.output_text.strip(), new_chat_id
    except Exception as e:
        return f"OpenAI error: {e}", chat_id


# --- Discord bot events ---
@bot.event
async def on_ready():
    print(f"{bot.user} is online and ready to chat!")
    if STATUS:
        await bot.change_presence(activity=discord.Game(STATUS))


@bot.event
async def on_message(message):
    if message.author == bot.user:
        return
    if bot.user in message.mentions:
        channel_id = str(message.channel.id)
        chat_id = CHANNEL_CHAT_IDS.get(channel_id)
        async with message.channel.typing():
            user_mention = f"<@{message.author.id}>"
            prompt = (
                message.content.replace(f"<@{bot.user.id}>", "")
                .replace(f"<@!{bot.user.id}>", "")
                .strip()
            )
            if not prompt:
                await message.reply(f"{user_mention}, Moon c√≥ th·ªÉ h·ªó tr·ª£ g√¨ ·∫°?")
                return
            answer, new_chat_id = await ask_openai(prompt, chat_id=chat_id)
            CHANNEL_CHAT_IDS[channel_id] = new_chat_id
            await message.reply(f"{user_mention} {answer}")
    await bot.process_commands(message)


async def log_current_time():
    import asyncio
    import datetime
    import logging

    while True:
        current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.basicConfig(level=logging.INFO)
        logging.info(f"Current time: {current_time}")
        # call request to FastAPI to keep it alive
        try:
            import httpx

            async with httpx.AsyncClient() as client:
                response = await client.get("https://moondiscord.onrender.com/")
                if response.status_code == 200:
                    logging.info("FastAPI is alive!")
                else:
                    logging.warning(
                        f"FastAPI returned status code: {response.status_code}"
                    )
        except Exception as e:
            logging.error(f"Error pinging FastAPI: {e}")

        # Sleep for 10 minutes
        await asyncio.sleep(600)


async def start_web():
    import os

    import uvicorn

    port = int(os.environ.get("PORT", 10000))
    config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="warning")
    server = uvicorn.Server(config)
    await server.serve()


async def main():
    # Start web server and logging in background
    web_task = asyncio.create_task(start_web())
    log_task = asyncio.create_task(log_current_time())
    # Start Discord bot (blocks until exit)
    try:
        await bot.start(DISCORD_TOKEN)
    except discord.errors.HTTPException as e:
        print(e)
        print("\n\n\nBLOCKED BY RATE LIMITS\nRESTARTING NOW\n\n\n")
        web_task.cancel()
        log_task.cancel()
        os.system("python restarter.py")
        os.system("kill 1")

    # Optionally, cancel background tasks if bot exits
    web_task.cancel()
    log_task.cancel()


if __name__ == "__main__":
    import nest_asyncio

    nest_asyncio.apply()
    asyncio.run(main())
